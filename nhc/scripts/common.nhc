# NHC - Common functions
#
# Michael Jennings <mej@lbl.gov>
# 15 December 2010
#
# $Id$
#

PASSWD_DATA_SRC="${PASSWD_DATA_SRC:-/etc/passwd}"

PWUID_USER=( )
PWUID_GID=( )
PWUID_GECOS=( )
PWUID_HOME=( )
PWUID_SHELL=( )

PWDATA_UIDS=( )
PWDATA_USERS=( )
PWDATA_SYSTEM_USERS=( )
PWDATA_USERID_MAP=''

# Define regexp match check conditionally based on bash version.
if [[ "${BASH_VERSINFO[0]}" != "" && ${BASH_VERSINFO[0]} -ge 3 ]]; then
    # Check to see if parameter ($1) matches regexp ($2)
    function mcheck_regexp() {
        if [[ "$1" =~ $2 ]]; then
            dbg "Regexp match check (internal):  $1 matches /$2/"
            return 0
        else
            dbg "Regexp match check (internal):  $1 does not match /$2/"
            return 1
        fi
    }

    # Check to see if a node range/list ($2) contains a node ($1)
    function mcheck_range() {
        local IFS=','
        local TARGET="$1"
        local RANGELIST="$2"
        local GROUP PREFIX SUFFIX RSTART REND WIDTH NODE i j

        for GROUP in $RANGELIST; do
            if [[ $GROUP =~ ^[-a-zA-Z0-9_]+[0-9]+[-\.a-zA-Z0-9]*$ ]]; then
                # Check a single node
                if [[ $TARGET == $GROUP ]]; then
                    dbg "$FUNCNAME:  Found $TARGET in $RANGELIST."
                    return 0
                fi
            elif [[ $GROUP =~ ^([-a-zA-Z0-9_]+)\[([0-9]+)\-([0-9]+)\]([-\.a-zA-Z0-9]*)$ ]]; then
                # Check a node range
                PREFIX=${BASH_REMATCH[1]}
                RSTART=${BASH_REMATCH[2]}
                REND=${BASH_REMATCH[3]}
                SUFFIX=${BASH_REMATCH[4]}
                WIDTH=${#RSTART}

                if [[ ${#RSTART} -lt ${#REND} ]]; then
                    dbg "$FUNCNAME:  Node range has mismatched widths of start ($RSTART) and end ($REND).  Using ${#REND}."
                    WIDTH=${#REND}
                fi

                if [[ $RSTART -gt $REND ]]; then
                    dbg "$FUNCNAME:  Node range has range reversed:  start ($RSTART) > end ($REND)."
                    j=$RSTART
                    RSTART=$REND
                    REND=$j
                fi

                for ((i=$RSTART; i <= $REND; i++)); do
                    NODE="$i"
                    while [[ ${#NODE} -lt $WIDTH ]]; do
                        NODE="0$NODE"
                    done
                    NODE="$PREFIX$NODE$SUFFIX"
                    if [[ $TARGET == $NODE ]]; then
                        dbg "$FUNCNAME:  Found $TARGET in $RANGELIST."
                        return 0
                    fi
                done
            else
                # Bad syntax
                log "$FUNCNAME:  Range not in pdsh syntax:  $GROUP"
                return 1
            fi
        done
        dbg "$FUNCNAME:  $TARGET NOT found in $RANGELIST."
        return 1
    }
else
    # Check to see if parameter ($1) matches regexp ($2) using egrep
    function mcheck_regexp() {
        if (echo "$1" | grep -E "$2" >/dev/null 2>&1); then
            dbg "Regexp match check (external):  $1 matches /$2/"
            return 0
        else
            dbg "Regexp match check (external):  $1 does not match /$2/"
            return 1
        fi
    }

    # Check to see if a node range/list ($2) contains a node ($1)
    function mcheck_range() {
        local IFS=','
        local TARGET="$1"
        local RANGELIST="$2"
        local GROUP PREFIX RSTART REND WIDTH NODE i j

        for GROUP in $RANGELIST; do
            if mcheck_regexp "$GROUP" '^[-a-zA-Z0-9_]+[0-9]+[-\.a-zA-Z0-9]*$' ; then
                # Check a single node
                if [[ $TARGET == $GROUP ]]; then
                    dbg "$FUNCNAME:  Found $TARGET in $RANGELIST."
                    return 0
                fi
            else
                PREFIX=""
                RSTART=""
                REND=""
                SUFFIX=""
                eval $(echo "$GROUP" | sed -re 's/^([-a-zA-Z0-9_]+)\[([0-9]+)\-([0-9]+)\]([-\.a-zA-Z0-9]*)$/PREFIX="\1" RSTART="\2" REND="\3" SUFFIX="\4"/')

                if [[ -n "$PREFIX" || -n "$RSTART" ]]; then
                    # Check a node range
                    WIDTH=${#RSTART}

                    if [[ ${#RSTART} -lt ${#REND} ]]; then
                        dbg "$FUNCNAME:  Node range has mismatched widths of start ($RSTART) and end ($REND).  Using ${#REND}."
                        WIDTH=${#REND}
                    fi

                    if [[ $RSTART -gt $REND ]]; then
                        dbg "$FUNCNAME:  Node range has range reversed:  start ($RSTART) > end ($REND)."
                        j=$RSTART
                        RSTART=$REND
                        REND=$j
                    fi

                    for ((i=$RSTART; i <= $REND; i++)); do
                        NODE="$i"
                        while [[ ${#NODE} -lt $WIDTH ]]; do
                            NODE="0$NODE"
                        done
                        NODE="$PREFIX$NODE$SUFFIX"
                        if [[ $TARGET == $NODE ]]; then
                            dbg "$FUNCNAME:  Found $TARGET in $RANGELIST."
                            return 0
                        fi
                    done
                else
                    # Bad syntax
                    log "$FUNCNAME:  Range not in pdsh syntax:  $GROUP"
                    return 1
                fi
            fi
        done
        dbg "$FUNCNAME:  $TARGET NOT found in $RANGELIST."
        return 1
    }
fi

# Check to see if parameter ($1) matches glob ($2)
function mcheck_glob() {
    case "$1" in
        $2) dbg "Glob match check:  $1 matches $2" ; return 0 ;;
        *)  dbg "Glob match check:  $1 does not match $2" ; return 1 ;;
    esac
}


# Detect regexp match (/.../), range match ({...}), or glob match (no
# slashes or braces), and call the appropriate mcheck_*() function
# above.
function mcheck() {
    local STRING="$1"
    local MATCH="$2"

    # Check to see if the current host matches the check we just read.
    if [[ "${MATCH#/}" != "$MATCH" && "${MATCH%/}" != "$MATCH" ]]; then
        # Regexp match syntax.  Strip slashes, then match.
        MATCH="${MATCH#/}"
        MATCH="${MATCH%/}"
        if mcheck_regexp "$STRING" "$MATCH" ; then
            return 0
        fi
    elif [[ "${MATCH#\{}" != "$MATCH" && "${MATCH%\}}" != "$MATCH" ]]; then
        # pdsh-style node range syntax.  Strip braces, then match.
        MATCH="${MATCH#\{}"
        MATCH="${MATCH%\}}"
        if mcheck_range "$STRING" "$MATCH" ; then
            return 0
        fi
    else
        # Glob match syntax
        if mcheck_glob "$STRING" "$MATCH" ; then
            return 0
        fi
    fi
    return 1
}

# Load configuration file from ($1)
function nhc_load_conf() {
    local CONFFILE="$1"
    local LINE TARGET CHECK

    # Load configuration file and match lines to current hostname.
    dbg "Loading configuration from $CONFFILE."
    while read LINE ; do
        TARGET="${LINE/%||*}"
        CHECK="${LINE/#*||}"

        # Trim whitespace.
        while [[ "${TARGET## }" != "${TARGET%% }" ]]; do
            TARGET="${TARGET## }"
            TARGET="${TARGET%% }"
        done
        while [[ "${CHECK## }" != "${CHECK%% }" ]]; do
            CHECK="${CHECK## }"
            CHECK="${CHECK%% }"
        done

        # Skip comments.
        if [[ "${TARGET###}" != "$TARGET" ]]; then
            continue
        fi

        # Skip empty targets or checks.
        test "$TARGET" = "" -o "$CHECK" = "" && continue

        # Check to see if the current host matches the check we just read.
        # If we didn't match, skip to the next line.
        mcheck "$HOSTNAME" "$TARGET" || continue

        # Add the check to our list.
        CHECKS[${#CHECKS[*]}]="$CHECK"
    done < "$CONFFILE"
}

# Parse colon-delimited passwd entry ($1), optionally storing uid in
# variable ($2).
function nhc_common_parse_passwd_entry() {
    local IFS=':'
    local PASSWD_ENTRY="$1"
    local UID_VAR="$2"
    local THIS_UID
    local -a LINE

    LINE=( $PASSWD_ENTRY )
    THIS_UID=${LINE[2]}
    PWDATA_UIDS[${#PWDATA_UIDS[*]}]=$THIS_UID
    PWUID_USER[$THIS_UID]="${LINE[0]}"
    PWUID_GID[$THIS_UID]=${LINE[3]}
    PWUID_GECOS[$THIS_UID]="${LINE[4]}"
    PWUID_HOME[$THIS_UID]="${LINE[5]}"
    PWUID_SHELL[$THIS_UID]="${LINE[6]}"

    PWDATA_USERS[${#PWDATA_USERS[*]}]="${LINE[0]}"
    if [[ $THIS_UID -lt 100 ]]; then
        PWDATA_SYSTEM_USERS[${#PWDATA_SYSTEM_USERS[*]}]="${LINE[0]}"
    fi
    PWDATA_USERID_MAP="$PWDATA_USERID_MAP||${LINE[0]}:$THIS_UID"
    if [[ -n "$UID_VAR" ]]; then
        eval $UID_VAR=$THIS_UID
    fi
}

# Load /etc/passwd data into arrays.
function nhc_common_load_passwd() {
    local PASSWD_ENTRY

    while read PASSWD_ENTRY ; do
        nhc_common_parse_passwd_entry "$PASSWD_ENTRY"
    done < $PASSWD_DATA_SRC
}

# Return UID for specified user ($1) into variable ($2).
function nhc_common_get_uid() {
    local THIS_USERID="$1"
    local THIS_VAR="$2"
    local THIS_UID
    local -a PASSWD_ENTRY

    if mcheck_regexp "$THIS_USERID" '^[0-9]+$' ; then
        # It's already a UID.  Just return it.
        eval $THIS_VAR=$THIS_USERID
        dbg "Got UID ${!THIS_VAR} for user $THIS_USERID"
        return
    fi

    if [[ "$PWDATA_USERID_MAP" = "||" ]]; then
        nhc_common_load_passwd
    fi

    THIS_UID="${PWDATA_USERID_MAP/#*||$THIS_USERID:}"
    THIS_UID="${THIS_UID/%||*}"
    dbg "Got UID $THIS_UID for user $THIS_USERID"

    if [[ -z "$THIS_UID" ]]; then
        # Fall back to getent invocation if passwd data is insufficient.
        nhc_common_parse_passwd_entry "$(getent passwd \"$THIS_USERID\")" THIS_UID
    fi
    eval $THIS_VAR=$THIS_UID
}

# Return userid for specified UID ($1) into variable ($2).
function nhc_common_get_userid() {
    local IFS
    local THIS_UID="$1"
    local THIS_VAR="$2"
    local THIS_USERID
    local -a PASSWD_ENTRY

    if mcheck_regexp "$THIS_UID" '[^0-9]' ; then
        # It's already a UID.  Just return it.
        eval $THIS_VAR=$THIS_UID
        dbg "Got userid ${!THIS_VAR} for UID $THIS_UID"
        return
    fi

    if [[ "$PWDATA_USERID_MAP" = "||" ]]; then
        nhc_common_load_passwd
    fi

    if [[ -n "${PWUID_USER[$THIS_UID]}" ]]; then
        THIS_USERID="${PWUID_USER[$THIS_UID]}"
        dbg "Got userid $THIS_USERID for UID $THIS_UID"
        eval $THIS_VAR=$THIS_USERID
    else
        # Fall back to getent invocation if passwd data is insufficient.
        nhc_common_parse_passwd_entry "$(getent passwd \"$THIS_USERID\")" THIS_UID
        eval $THIS_VAR=${PWUID_USER[$THIS_UID]}
    fi
}
